# Задача 1. Снова числа Фибоначчи

Напишите ещё раз программу, которая реализует рекурсивный подсчёт чисел Фибоначчи. Не заглядывайте в ваше предыдущее решение, постарайтесь написать его заново.

Кроме написания кода нужно оценить сложность вашего алгоритма вычисления n-го числа Фибоначчи по скорости и по памяти.

# Problem 1. Fibonacci numbers again

Write again a program that implements recursive calculation of Fibonacci numbers. Don't look at your previous solution, try to write it again.

In addition to writing code, you need to evaluate the complexity of your algorithm for calculating the nth Fibonacci number in terms of speed and memory.

# Задача 2. Ускоряем Фибоначчи

Наивное решение задачи по вычислению чисел Фибоначчи является довольно дорогим по времени, при этом совсем не использует дополнительную память. Давайте исправим это с помощью применения динамического программирования к рекурсии.

Ваша задача — изменить алгоритм вычисления n-го числа Фибоначчи так, чтобы сложность алгоритма по скорости составляла `O(n)` и по памяти тоже была порядка `O(n)`.

# Task 2. Accelerate Fibonacci

The naive solution to the problem of calculating Fibonacci numbers is quite time-consuming, and does not use any additional memory at all. Let's fix this by applying dynamic programming to recursion.

Your task is to change the algorithm for calculating the nth Fibonacci number so that the speed complexity of the algorithm is `O(n)` and the memory complexity is also of the order of `O(n)`.
